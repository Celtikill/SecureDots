#!/usr/bin/env zsh
# Conda initialization - Multi-platform conda setup
# This module handles conda initialization with comprehensive fallback mechanisms

# Skip if conda is already initialized or if lazy loading is disabled
[[ -n "${CONDA_EXE:-}" ]] && return 0
[[ "${CONDA_LAZY_LOAD:-true}" == "true" ]] && return 0

# Initialize conda detection
_conda_init() {
    local conda_path="$1"
    
    # Validate conda installation
    [[ ! -x "$conda_path/bin/conda" ]] && return 1
    
    # Method 1: Use conda's shell hook (most robust)
    local __conda_setup
    __conda_setup="$("$conda_path/bin/conda" shell.zsh hook 2>/dev/null)"
    if [[ $? -eq 0 ]]; then
        eval "$__conda_setup"
        unset __conda_setup
        export CONDA_INIT_METHOD="shell_hook"
        return 0
    fi
    
    # Method 2: Source conda profile script
    if [[ -f "$conda_path/etc/profile.d/conda.sh" ]]; then
        source "$conda_path/etc/profile.d/conda.sh" 2>/dev/null
        if command -v conda &>/dev/null; then
            export CONDA_INIT_METHOD="profile_script"
            return 0
        fi
    fi
    
    # Method 3: Manual PATH setup (fallback)
    export PATH="$conda_path/bin:$PATH"
    export CONDA_EXE="$conda_path/bin/conda"
    export CONDA_PYTHON_EXE="$conda_path/bin/python"
    
    # Verify conda is now available
    if command -v conda &>/dev/null; then
        export CONDA_INIT_METHOD="manual_path"
        return 0
    fi
    
    return 1
}

# Main conda initialization logic
_conda_main() {
    # Use platform-specific search paths or fallback to defaults
    local conda_search_paths
    if [[ -n "${CONDA_SEARCH_PATHS:-}" ]]; then
        conda_search_paths=("${CONDA_SEARCH_PATHS[@]}")
    else
        # Fallback paths if platform detection failed
        conda_search_paths=(
            "$HOME/miniconda3"
            "$HOME/anaconda3"
            "/opt/conda"
            "/opt/miniconda3"
            "/opt/anaconda3"
            "/usr/local/miniconda3"
            "/usr/local/anaconda3"
        )
    fi
    
    # Allow user override for custom conda installations
    if [[ -n "${CONDA_CUSTOM_PATH:-}" ]]; then
        conda_search_paths=("$CONDA_CUSTOM_PATH" "${conda_search_paths[@]}")
    fi
    
    # Find and initialize the first valid conda installation
    for conda_path in "${conda_search_paths[@]}"; do
        if _conda_init "$conda_path"; then
            # Export conda info for other scripts
            export CONDA_BASE="$conda_path"
            
            # Auto-activate base environment (configurable)
            if [[ "${CONDA_AUTO_ACTIVATE:-true}" == "true" ]]; then
                # Skip auto-activation in containers unless explicitly requested
                if [[ "${PLATFORM:-}" != *container* || "${CONDA_FORCE_ACTIVATE:-false}" == "true" ]]; then
                    if [[ -z "${CONDA_DEFAULT_ENV:-}" ]] && command -v conda &>/dev/null; then
                        conda activate base 2>/dev/null || true
                    fi
                fi
            fi
            
            return 0
        fi
    done
    
    # No conda installation found
    return 1
}

# Execute conda initialization
_conda_main

# Clean up functions
unset -f _conda_init _conda_main

# ===== Conda Environment Management Functions =====

# Generate platform-specific environments.txt
conda_refresh_environments() {
    local conda_dir="$HOME/.conda"
    local env_file="$conda_dir/environments.txt"
    
    # Create conda directory if it doesn't exist
    [[ ! -d "$conda_dir" ]] && mkdir -p "$conda_dir"
    
    # Only proceed if conda is available
    if ! command -v conda &>/dev/null; then
        echo "Conda not available - skipping environment refresh"
        return 1
    fi
    
    # Generate header
    cat > "$env_file" << 'EOF'
# Conda environments - automatically generated for this platform
# This file is managed locally to avoid cross-platform conflicts
# Generated by conda_refresh_environments()

EOF
    
    # Add base conda installation
    if [[ -n "${CONDA_BASE:-}" ]]; then
        echo "$CONDA_BASE" >> "$env_file"
    fi
    
    # Add all conda environments
    if conda env list --json &>/dev/null; then
        # Use JSON output for more reliable parsing
        conda env list --json | python3 -c "
import json, sys
try:
    data = json.load(sys.stdin)
    for env in data['envs']:
        print(env)
except:
    pass
" >> "$env_file" 2>/dev/null
    else
        # Fallback to text parsing
        conda env list | grep -E '^[^#]' | awk '{print $NF}' | grep -E '^/' >> "$env_file" 2>/dev/null
    fi
    
    # Sort and remove duplicates
    if [[ -f "$env_file" ]]; then
        local temp_file=$(mktemp)
        grep -E '^#|^$' "$env_file" > "$temp_file"
        grep -v -E '^#|^$' "$env_file" | sort -u >> "$temp_file"
        mv "$temp_file" "$env_file"
    fi
    
    echo "Conda environments refreshed: $env_file"
}

# List conda environments with helpful formatting
conda_list_environments() {
    echo "🐍 Conda Environments"
    echo "===================="
    echo
    
    if ! command -v conda &>/dev/null; then
        echo "❌ Conda not available"
        echo "Try running: conda_refresh_environments"
        return 1
    fi
    
    echo "Active Environment: ${CONDA_DEFAULT_ENV:-base}"
    echo "Conda Base: ${CONDA_BASE:-Unknown}"
    echo "Initialization Method: ${CONDA_INIT_METHOD:-Unknown}"
    echo
    
    echo "Available Environments:"
    conda env list | grep -v '^#' | while read -r name path; do
        if [[ -n "$name" && -n "$path" ]]; then
            local marker=""
            [[ "$name" == "${CONDA_DEFAULT_ENV:-}" ]] && marker="*"
            echo "  $marker $name -> $path"
        fi
    done
    
    echo
    echo "To refresh environment list: conda_refresh_environments"
}

# Quick environment activation with error handling
conda_activate() {
    local env_name="$1"
    
    if [[ -z "$env_name" ]]; then
        echo "Usage: conda_activate <environment_name>"
        echo "Available environments:"
        conda env list | grep -v '^#' | awk '{print "  " $1}'
        return 1
    fi
    
    if ! command -v conda &>/dev/null; then
        echo "❌ Conda not available"
        return 1
    fi
    
    if conda activate "$env_name" 2>/dev/null; then
        echo "✅ Activated conda environment: $env_name"
    else
        echo "❌ Failed to activate environment: $env_name"
        echo "Available environments:"
        conda env list | grep -v '^#' | awk '{print "  " $1}'
        return 1
    fi
}

# Disable auto-refresh by default for faster startup
# Enable with: export CONDA_AUTO_REFRESH=true
if [[ "${CONDA_AUTO_REFRESH:-false}" == "true" && -n "${CONDA_BASE:-}" ]]; then
    # Run in background to avoid slowing shell startup
    (conda_refresh_environments &)
fi

# ===== Lazy Loading Functions =====

# Lazy conda initialization function
conda_init_lazy() {
    # Temporarily disable lazy loading to actually initialize
    local old_lazy="${CONDA_LAZY_LOAD:-true}"
    export CONDA_LAZY_LOAD=false
    
    # Source this file again to run initialization
    source "${ZSH_CONFIG_DIR}/conda.zsh"
    
    # Restore lazy loading setting
    export CONDA_LAZY_LOAD="$old_lazy"
    
    echo "✅ Conda initialized lazily"
}

# Create lazy wrappers for conda commands
if [[ "${CONDA_LAZY_LOAD:-true}" == "true" ]]; then
    # Only create wrappers if conda isn't already available
    if ! command -v conda &>/dev/null; then
        for cmd in conda mamba; do
            eval "${cmd}() {
                unset -f conda mamba 2>/dev/null
                conda_init_lazy
                if command -v ${cmd} &>/dev/null; then
                    ${cmd} \"\$@\"
                else
                    echo \"❌ ${cmd} not available after initialization\" >&2
                    return 1
                fi
            }"
        done
        
        echo "📦 Conda lazy loading enabled (use 'conda' command to initialize)"
    fi
fi