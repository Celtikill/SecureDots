#!/bin/bash
# Test GPG Configuration
# Comprehensive testing for GPG agent and configuration management

# Disable strict error checking for tests
set +euo pipefail

# Get the directory of this script
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
DOTFILES_DIR="$(dirname "$SCRIPT_DIR")"

# Source test framework
source "$SCRIPT_DIR/test-framework.sh"

# Setup and teardown for GPG tests
setup() {
    setup_test_environment "gpg"
    # Create mock GPG directories
    mkdir -p "$TEST_GNUPG_DIR"
    chmod 700 "$TEST_GNUPG_DIR"
}

teardown() {
    cleanup_test_environment
}

# Test GPG agent configuration generation
test_gpg_agent_config_generation() {
    local gpg_agent_conf="$TEST_GNUPG_DIR/gpg-agent.conf"
    
    # Test Apple Silicon configuration
    if [[ -f "/opt/homebrew/bin/pinentry-mac" ]]; then
        local expected_pinentry="/opt/homebrew/bin/pinentry-mac"
    elif [[ -f "/usr/local/bin/pinentry-mac" ]]; then
        local expected_pinentry="/usr/local/bin/pinentry-mac"
    else
        local expected_pinentry="/usr/bin/pinentry-curses"
    fi
    
    # Create a test config
    cat > "$gpg_agent_conf" << EOF
# GPG Agent configuration
# Generated by setup script on $(date)
# Platform: $(uname -s)

default-cache-ttl 0
max-cache-ttl 0
default-cache-ttl-ssh 0
max-cache-ttl-ssh 0
pinentry-program $expected_pinentry
enable-ssh-support
no-allow-external-cache
card-timeout 0
EOF
    
    chmod 600 "$gpg_agent_conf"
    
    # Verify the configuration
    assert_file_exists "$gpg_agent_conf" "GPG agent config should be created"
    assert_file_permissions "$gpg_agent_conf" "600" "GPG agent config should have correct permissions"
    assert_gpg_config "$gpg_agent_conf" "pinentry-program $expected_pinentry" "Should contain correct pinentry program"
    assert_gpg_config "$gpg_agent_conf" "default-cache-ttl 0" "Should have hardware key optimized cache settings"
    assert_gpg_config "$gpg_agent_conf" "enable-ssh-support" "Should enable SSH support"
}

test_pinentry_program_detection() {
    # Test the improved pinentry detection logic from setup script
    local pinentry_program=""
    local brew_prefix=""

    case "$(uname -s)" in
        Darwin*)
            # Get Homebrew prefix dynamically
            if command -v brew &>/dev/null; then
                brew_prefix="$(brew --prefix 2>/dev/null)"
            fi

            # Check candidates in priority order
            local candidates=(
                "${brew_prefix}/bin/pinentry-mac"
                "/opt/homebrew/bin/pinentry-mac"
                "/usr/local/bin/pinentry-mac"
            )

            # Try pinentry-mac first
            for candidate in "${candidates[@]}"; do
                if [[ -n "$candidate" && -x "$candidate" ]]; then
                    pinentry_program="$candidate"
                    break
                fi
            done

            # Fallback to PATH
            if [[ -z "$pinentry_program" ]] && command -v pinentry-mac &>/dev/null; then
                pinentry_program="$(command -v pinentry-mac)"
            fi

            # Fallback to curses
            if [[ -z "$pinentry_program" ]]; then
                local curses_candidates=(
                    "${brew_prefix}/bin/pinentry-curses"
                    "/opt/homebrew/bin/pinentry-curses"
                    "/usr/local/bin/pinentry-curses"
                    "/usr/bin/pinentry-curses"
                )
                for candidate in "${curses_candidates[@]}"; do
                    if [[ -n "$candidate" && -x "$candidate" ]]; then
                        pinentry_program="$candidate"
                        break
                    fi
                done
            fi

            # Last resort
            if [[ -z "$pinentry_program" ]] && command -v pinentry &>/dev/null; then
                pinentry_program="$(command -v pinentry)"
            fi
            ;;
        Linux*)
            local linux_candidates=(
                "/usr/bin/pinentry-curses"
                "/usr/bin/pinentry-tty"
                "/usr/bin/pinentry"
            )
            for candidate in "${linux_candidates[@]}"; do
                if [[ -x "$candidate" ]]; then
                    pinentry_program="$candidate"
                    break
                fi
            done

            # Try PATH if not found
            if [[ -z "$pinentry_program" ]] && command -v pinentry-curses &>/dev/null; then
                pinentry_program="$(command -v pinentry-curses)"
            elif [[ -z "$pinentry_program" ]] && command -v pinentry &>/dev/null; then
                pinentry_program="$(command -v pinentry)"
            fi
            ;;
    esac

    # If no pinentry found, skip the test with installation instructions
    if [[ -z "$pinentry_program" ]]; then
        skip_test "No pinentry program found" "Install with: brew install pinentry-mac"
        return 0
    fi

    assert_true "[[ -n '$pinentry_program' ]]" "Should detect a pinentry program"
    assert_true "[[ -x '$pinentry_program' ]]" "Detected pinentry should be executable"
    assert_file_exists "$pinentry_program" "Detected pinentry program should exist"
}

test_gpg_config_update_logic() {
    local gpg_agent_conf="$TEST_GNUPG_DIR/gpg-agent.conf"
    
    # Create initial config with old pinentry
    cat > "$gpg_agent_conf" << 'EOF'
# Old configuration
default-cache-ttl 600
pinentry-program /usr/bin/pinentry-curses
enable-ssh-support
EOF
    
    # Simulate the update logic
    local new_pinentry="/opt/homebrew/bin/pinentry-mac"
    local current_pinentry=$(grep "^pinentry-program" "$gpg_agent_conf" | awk '{print $2}')
    
    assert_equals "/usr/bin/pinentry-curses" "$current_pinentry" "Should read current pinentry correctly"
    
    # Test backup creation logic
    if [[ "$current_pinentry" != "$new_pinentry" ]]; then
        cp "$gpg_agent_conf" "${gpg_agent_conf}.backup"
        assert_file_exists "${gpg_agent_conf}.backup" "Should create backup before updating"
        
        # Update pinentry program
        sed -i.tmp "s|^pinentry-program .*|pinentry-program $new_pinentry|" "$gpg_agent_conf"
        rm -f "${gpg_agent_conf}.tmp"
        
        # Verify update
        local updated_pinentry=$(grep "^pinentry-program" "$gpg_agent_conf" | awk '{print $2}')
        assert_equals "$new_pinentry" "$updated_pinentry" "Should update pinentry program correctly"
    fi
}

test_gpg_agent_security_settings() {
    local gpg_agent_conf="$TEST_GNUPG_DIR/gpg-agent.conf"
    
    # Create config with security-focused settings
    cat > "$gpg_agent_conf" << 'EOF'
# Security-focused configuration
default-cache-ttl 0
max-cache-ttl 0
default-cache-ttl-ssh 0
max-cache-ttl-ssh 0
no-allow-external-cache
card-timeout 0
pinentry-program /opt/homebrew/bin/pinentry-mac
enable-ssh-support
EOF
    
    # Verify security settings
    assert_gpg_config "$gpg_agent_conf" "default-cache-ttl 0" "Should not cache credentials"
    assert_gpg_config "$gpg_agent_conf" "max-cache-ttl 0" "Should not cache credentials long-term"
    assert_gpg_config "$gpg_agent_conf" "no-allow-external-cache" "Should prevent external caching"
    assert_gpg_config "$gpg_agent_conf" "card-timeout 0" "Should not cache card status"
    
    # Ensure no insecure settings
    assert_true "! grep -q 'default-cache-ttl [1-9]' '$gpg_agent_conf'" "Should not have insecure cache TTL"
}

test_gpg_directory_permissions() {
    # Test that GPG directories have correct permissions
    assert_dir_exists "$TEST_GNUPG_DIR" "GPG directory should exist"
    
    # Check directory permissions (should be 700)
    local dir_perms=$(stat -f "%OLp" "$TEST_GNUPG_DIR" 2>/dev/null || stat -c "%a" "$TEST_GNUPG_DIR" 2>/dev/null)
    assert_equals "700" "$dir_perms" "GPG directory should have 700 permissions"
    
    # Test file creation in GPG directory
    local test_file="$TEST_GNUPG_DIR/test_file"
    echo "test" > "$test_file"
    chmod 600 "$test_file"
    
    assert_file_permissions "$test_file" "600" "Files in GPG directory should have 600 permissions"
    
    rm -f "$test_file"
}

test_gpg_agent_restart_simulation() {
    # Test that GPG agent restart commands work
    local restart_commands=(
        "gpgconf --kill gpg-agent"
        "gpgconf --launch gpg-agent"
    )
    
    for cmd in "${restart_commands[@]}"; do
        # Test that command doesn't fail (even if no GPG agent is running)
        assert_true "$cmd 2>/dev/null || true" "GPG agent command should not cause errors: $cmd"
    done
}

test_hardware_key_detection() {
    # Mock hardware key presence
    mock_yubikey_present
    
    # Test card status simulation
    local card_status=$(mock_gpg_command "--card-status")
    assert_contains "$card_status" "Card available" "Should detect card when present"
    assert_contains "$card_status" "Yubico" "Should identify Yubico card"
    
    # Mock hardware key absence
    mock_yubikey_absent
    
    local no_card_status=$(mock_gpg_command "--card-status")
    assert_contains "$no_card_status" "No such device" "Should report no device when absent"
}

test_gpg_key_simulation() {
    # Mock GPG keys present
    export MOCK_GPG_KEYS="present"

    local key_output=$(mock_gpg_command "--list-secret-keys")
    assert_contains "$key_output" "sec" "Should show secret key when present"
    assert_contains "$key_output" "Test User" "Should show user ID"

    # Mock no GPG keys
    export MOCK_GPG_KEYS="absent"

    # Capture exit code before capturing output
    mock_gpg_command "--list-secret-keys" >/dev/null 2>&1
    local exit_code=$?
    assert_equals "2" "$exit_code" "Should return error code when no keys present"
}

test_platform_specific_pinentry() {
    # Test platform-specific pinentry selection
    if [[ "$(uname -s)" == "Darwin" ]]; then
        # macOS should prefer GUI pinentry
        local preferred_paths=(
            "/opt/homebrew/bin/pinentry-mac"
            "/usr/local/bin/pinentry-mac"
        )
        
        local found_gui_pinentry=false
        for path in "${preferred_paths[@]}"; do
            if [[ -f "$path" ]]; then
                found_gui_pinentry=true
                assert_pinentry_path "$path" "Should find GUI pinentry on macOS"
                break
            fi
        done
        
        if [[ "$found_gui_pinentry" == "false" ]]; then
            skip_test "No GUI pinentry found" "Install with: brew install pinentry-mac"
        fi
    else
        # Linux should use curses pinentry
        if [[ -f "/usr/bin/pinentry-curses" ]]; then
            assert_pinentry_path "/usr/bin/pinentry-curses" "Should find curses pinentry on Linux"
        fi
    fi
}

test_config_file_generation_robustness() {
    # Test that config generation handles various scenarios
    local gpg_agent_conf="$TEST_GNUPG_DIR/gpg-agent.conf"
    
    # Test with missing directory
    rm -rf "$TEST_GNUPG_DIR"
    mkdir -p "$TEST_GNUPG_DIR"
    chmod 700 "$TEST_GNUPG_DIR"
    
    # Generate config
    cat > "$gpg_agent_conf" << 'EOF'
# Generated config
default-cache-ttl 0
pinentry-program /opt/homebrew/bin/pinentry-mac
EOF
    
    assert_file_exists "$gpg_agent_conf" "Should create config in new directory"
    
    # Test with existing config - should not overwrite comments
    echo "# User comment" >> "$gpg_agent_conf"
    echo "custom-setting value" >> "$gpg_agent_conf"
    
    local orig_content=$(cat "$gpg_agent_conf")
    
    # Simulate careful update (only change specific lines)
    if grep -q "^pinentry-program" "$gpg_agent_conf"; then
        sed -i.bak 's|^pinentry-program .*|pinentry-program /usr/local/bin/pinentry-mac|' "$gpg_agent_conf"
    fi
    
    local new_content=$(cat "$gpg_agent_conf")
    
    # Should preserve user comments and custom settings
    assert_contains "$new_content" "# User comment" "Should preserve user comments"
    assert_contains "$new_content" "custom-setting value" "Should preserve custom settings"
    assert_contains "$new_content" "/usr/local/bin/pinentry-mac" "Should update pinentry path"
}

test_error_handling() {
    # Test behavior with invalid configurations
    local gpg_agent_conf="$TEST_GNUPG_DIR/gpg-agent.conf"
    
    # Test with invalid pinentry path
    cat > "$gpg_agent_conf" << 'EOF'
pinentry-program /nonexistent/path
EOF
    
    assert_file_exists "$gpg_agent_conf" "Config with invalid pinentry should still be created"
    
    # Test with read-only directory (simulate permission error)
    local readonly_dir="$TEST_ENV_DIR/readonly"
    mkdir -p "$readonly_dir"
    chmod 444 "$readonly_dir"
    
    # Should handle permission errors gracefully
    assert_true "! touch '$readonly_dir/test' 2>/dev/null" "Should not be able to write to read-only directory"
    
    chmod 755 "$readonly_dir"  # Clean up
}

# Run tests with setup/teardown
describe "GPG Configuration Tests"

run_test "GPG agent config generation" test_gpg_agent_config_generation
run_test "Pinentry program detection" test_pinentry_program_detection
run_test "GPG config update logic" test_gpg_config_update_logic
run_test "GPG agent security settings" test_gpg_agent_security_settings

describe "GPG Directory and Permissions Tests"

run_test "GPG directory permissions" test_gpg_directory_permissions
run_test "GPG agent restart simulation" test_gpg_agent_restart_simulation

describe "Hardware Key Simulation Tests"

run_test "Hardware key detection" test_hardware_key_detection
run_test "GPG key simulation" test_gpg_key_simulation

describe "Platform-Specific Configuration Tests"

run_test "Platform-specific pinentry" test_platform_specific_pinentry
run_test "Config file generation robustness" test_config_file_generation_robustness
run_test "Error handling" test_error_handling

# Clean up
teardown

# Print test summary
print_summary